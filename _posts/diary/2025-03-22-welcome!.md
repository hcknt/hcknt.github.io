---
title: "Welcome! and Testing!"
date: 2025-03-22
last_modified_at: 2025-03-23
categories:
  - diary
tags:
  - test
  - diary
---

You'll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run `jekyll serve`, which launches a web server and auto-regenerates your site when a file is updated.

To add new posts, simply add a file in the `_posts` directory that follows the convention `YYYY-MM-DD-name-of-post.ext` and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.

Jekyll also offers powerful support for code snippets:

```cpp
#include <iostream>

int main(void) {
  std::cout << "It's not shutting down." << '\n';
}
// prints...
```

Check out the [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyllâ€™s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/

## Computer Architecture and Instruction Set Architecture

**Computer Architecture** refers to how the features of HW and SW are designed and how they are organized. It includes the design of computer's functional architecture, instruction set architecture, microarchitecture, and other HW and computing methods.

### Subdivisions of Computer Architecture

- Designing a computer's functional architecture
  - Von Neumann architecture: Most PCs and servers, uses shared memory for instructions and data
  - Harvard architecture: DSPs and microcontrollers, separate instruction and data memory
  - Modified Harvard architecture: ARM Cortex-M, separate caches but shared main memory
- Instruction Set architecture
  - x86, x86-64(a.k.a. x64, AMD64, Intel 64): Intel Core i7, AMD Ryzen, CISC with variable-length instructions
  - ARM: Apple M1/M2, Qualcomm Snapdragon, RISC architecture for mobile/embedded devices
  - MIPS: PlayStation 1-2, Nintendo 64, RISC with fixed 32-bit instructions
  - AVR: Arduino microcontrollers, 8-bit RISC for embedded systems
- Microarchitecture
  - Cache design: Multi-level caches (L1/L2/L3) with different access speeds
  - Pipelining: Breaking instruction execution into stages for parallelism
  - Superscalar: AMD Zen, Intel Core, executing multiple instructions simultaneously
  - Branch prediction: Predicts which path conditional code will take to avoid pipeline stalls
  - Non-sequential instruction processing: Out-of-order execution optimizing instruction flow
- Hardware and computing methodology
  - Direct memory access: Allows peripherals to access memory independently of CPU

This repo will concentrate on studying the **Von neumann architecture** and **x86-64**.

### Von Neumann Architecture

Von Neumann Architecture contains three core functionalities: <u>compute</u>, <u>control</u>, and <u>store</u>. Modern computers use **central processing units(CPUs)** for computation and control, **memory** for storage, and electronic pathways called **bus** to exchange data or control signals between devices.

<a title="Kapooht, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Von_Neumann_Architecture.svg"><img width="" alt="Von Neumann Architecture" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Von_Neumann_Architecture.svg/256px-Von_Neumann_Architecture.svg.png?20130427233915"></a>

<a href="https://commons.wikimedia.org/wiki/File:Von_Neumann_Architecture.svg">Kapooht</a>, <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via Wikimedia Commons

